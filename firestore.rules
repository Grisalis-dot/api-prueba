rules_version = '2';

/**
 * FIRESTORE SECURITY RULES - PROTOTYPING MODE
 * 
 * CORE PHILOSOPHY:
 * This ruleset implements a Role-Based Access Control (RBAC) model combined with authenticated 
 * global read access. While data shapes are flexible to support rapid development, 
 * authorization is strictly enforced based on the user's authentication status and 
 * administrative roles.
 * 
 * DATA STRUCTURE:
 * - /assets/{assetId}: Global repository for IT assets.
 * - /roles_admin/{uid}: A flat collection where the presence of a UID document grants admin privileges.
 * 
 * KEY SECURITY DECISIONS:
 * 1. Role-Based Writes: Since the 'Asset' entity lacks specific ownership fields (like ownerId), 
 *    write operations (create, update, delete) are restricted to users identified as administrators 
 *    via the /roles_admin collection.
 * 2. Authenticated Reads: Assets are visible to any signed-in user, supporting a transparent 
 *    internal IT catalog.
 * 3. Authorization Independence: Admin status is determined by document existence in a dedicated 
 *    collection, avoiding complex nested lookups or custom claims.
 * 4. Relational Integrity: On creation, the rules enforce that the internal 'id' field of an 
 *    asset matches its document ID in the path.
 * 
 * DENORMALIZATION FOR AUTHORIZATION:
 * - Admin roles are stored in a top-level collection (/roles_admin) to allow for simple exists() 
 *   checks during write operations on other collections.
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // --- GLOBAL HELPER FUNCTIONS ---

    /** 
     * @description Checks if the request is made by an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /** 
     * @description Checks if the authenticated user has an entry in the roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /** 
     * @description Combines admin check with a verification that the resource exists.
     * Used for update and delete operations.
     */
    function isExistingAdmin() {
      return isAdmin() && resource != null;
    }

    // --- COLLECTION RULES ---

    /**
     * @description Primary storage for IT Asset entities. Accessible to all users for reading, 
     * but restricted to administrators for any modifications.
     * @path /assets/{assetId}
     * @allow (get/list) if user is signed in.
     * @allow (create/update/delete) if user's UID exists in /roles_admin.
     * @deny (write) if user is not an administrator.
     * @principle Role-based access control for resource management.
     */
    match /assets/{assetId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin() && request.resource.data.id == assetId;
      allow update: if isExistingAdmin() && request.resource.data.id == resource.data.id;
      allow delete: if isExistingAdmin();
    }

    /**
     * @description Registry of administrative users. The existence of a document here 
     * grants system-wide write permissions.
     * @path /roles_admin/{uid}
     * @allow (get) if user is checking their own admin status.
     * @allow (list) if user is an existing administrator.
     * @deny (write) via client SDK; admin roles should be managed via Admin SDK or Console.
     * @principle Database-level role flags for authorization independence.
     */
    match /roles_admin/{uid} {
      allow get: if isSignedIn() && request.auth.uid == uid;
      allow list: if isAdmin();
      // Writes are denied by default to prevent users from escalating their own privileges.
      // Admin roles should be assigned through secure backend processes.
      allow create, update, delete: if false;
    }

    // --- DEFAULT DENY ---
    // Explicitly deny access to any other collections not defined above.
    match /{path=**} {
      allow read, write: if false;
    }
  }
}